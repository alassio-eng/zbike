<!DOCTYPE html>
<html lang="it">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Zbike 2 - Allenamenti</title>
    <link href="https://fonts.googleapis.com/css2?family=Chakra+Petch:wght@300;400;600;700&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.0/dist/chart.umd.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            min-height: 100vh;
            background: linear-gradient(135deg, #0a0e27 0%, #1a1f3a 50%, #0f1428 100%);
            color: #fff;
            font-family: 'Chakra Petch', monospace;
            padding: 10px;
            transform: scale(0.7);
            transform-origin: top center;
            width: 142.857%; /* 100 / 0.7 per compensare lo scale */
            margin-left: -21.4285%; /* (142.857 - 100) / 2 per centrare */
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        h1 {
            font-size: 24px;
            font-weight: 700;
            background: linear-gradient(135deg, #00ff88 0%, #00d4ff 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 5px;
        }

        .subtitle {
            color: #00ff88;
            font-size: 14px;
            letter-spacing: 3px;
            text-transform: uppercase;
        }

        .tabs {
            display: flex;
            gap: 10px;
            margin-bottom: 5px;
            padding-bottom: 10px;
            border-bottom: 2px solid rgba(255, 255, 255, 0.1);
        }

        .tab {
            padding: 12px 24px;
            background: transparent;
            border: none;
            color: #666;
            font-family: inherit;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .tab:hover {
            color: #00ff88;
        }

        .tab.active {
            color: #00ff88;
            border-bottom-color: #00ff88;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block;
        }

        .btn {
            padding: 12px 24px;
            font-size: 14px;
            font-weight: 600;
            border: 2px solid #00ff88;
            background: rgba(0, 255, 136, 0.1);
            color: #00ff88;
            border-radius: 8px;
            cursor: pointer;
            font-family: inherit;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.3s ease;
        }

        .btn:hover:not(:disabled) {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.05);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .btn.small {
            padding: 8px 16px;
            font-size: 12px;
        }

        .btn.danger {
            border-color: #ff3366;
            background: rgba(255, 51, 102, 0.1);
            color: #ff3366;
        }

        .btn.secondary {
            border-color: #00d4ff;
            background: rgba(0, 212, 255, 0.1);
            color: #00d4ff;
        }

        .panel {
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 15px;
            margin-bottom: 15px;
            backdrop-filter: blur(10px);
        }

        .panel h2 {
            font-size: 20px;
            margin-bottom: 20px;
            color: #00ff88;
            text-transform: uppercase;
            letter-spacing: 2px;
        }

        .workout-list {
            display: grid;
            gap: 15px;
        }

        .workout-item {
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 12px;
            padding: 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: all 0.3s ease;
        }

        .workout-item:hover {
            border-color: rgba(0, 255, 136, 0.3);
            background: rgba(0, 255, 136, 0.05);
        }

        .workout-info h3 {
            font-size: 16px;
            color: #00ff88;
            margin-bottom: 8px;
        }

        .workout-meta {
            font-size: 13px;
            color: #888;
        }

        .workout-actions {
            display: flex;
            gap: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            font-size: 13px;
            color: #00ff88;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        .form-group input, .form-group select {
            width: 100%;
            padding: 12px;
            background: rgba(0, 0, 0, 0.3);
            border: 1px solid rgba(255, 255, 255, 0.2);
            border-radius: 8px;
            color: #fff;
            font-family: inherit;
            font-size: 14px;
        }

        .form-group input:focus, .form-group select:focus {
            outline: none;
            border-color: #00ff88;
        }

        .phase-list {
            margin-bottom: 20px;
        }

        .phase-item {
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 10px;
        }

        .phase-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 10px;
        }

        .phase-title {
            font-size: 14px;
            color: #00d4ff;
            font-weight: 600;
        }

        .phase-fields {
            display: grid;
            grid-template-columns: 2fr 1fr 1fr;
            gap: 10px;
        }

        .workout-runner {
            text-align: center;
        }

        .current-phase {
            font-size: 32px;
            font-weight: 700;
            color: #00ff88;
            margin-bottom: 10px;
        }

        .phase-progress {
            background: rgba(0, 0, 0, 0.3);
            border-radius: 12px;
            height: 24px;
            margin: 20px 0;
            overflow: hidden;
            position: relative;
        }

        .phase-progress-bar {
            height: 100%;
            background: linear-gradient(90deg, #00ff88 0%, #00d4ff 100%);
            transition: width 0.3s ease;
        }

        .phase-progress-text {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 13px;
            font-weight: 600;
        }

        .next-phase {
            font-size: 14px;
            color: #888;
            margin-top: 15px;
        }

        .workout-controls {
            display: flex;
            gap: 15px;
            justify-content: center;
            margin-top: 30px;
        }

        .level-grid {
            display: grid;
            grid-template-columns: repeat(5, 1fr);
            gap: 6px;
            margin-top: 15px;
        }

        .level-btn {
            padding: 8px 4px;
            font-size: 18px;
            font-weight: 700;
            border: 2px solid rgba(255, 255, 255, 0.2);
            background: rgba(255, 255, 255, 0.05);
            color: #666;
            border-radius: 10px;
            cursor: pointer;
            font-family: inherit;
            transition: all 0.3s ease;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            min-height: 55px;
        }

        .level-btn:hover:not(:disabled) {
            transform: scale(1.05);
            border-color: rgba(255, 255, 255, 0.4);
        }

        .level-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .level-btn.active {
            border-color: #00ff88;
            background: rgba(0, 255, 136, 0.2);
            color: #00ff88;
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.4);
        }

        .metrics {
            display: grid !important;
            grid-template-columns: repeat(2, 1fr) !important;
            gap: 8px;
            margin-bottom: 15px;
            width: 100%;
        }

        .metric-card {
            background: rgba(0, 255, 136, 0.05);
            border: 1px solid rgba(0, 255, 136, 0.2);
            border-radius: 8px;
            padding: 8px 4px;
            text-align: center;
            min-width: 0;
            overflow: hidden;
        }

        .metric-label {
            font-size: 12px;
            color: #888;
            text-transform: uppercase;
            margin-bottom: 8px;
        }

        .metric-value {
            font-size: 32px;
            font-weight: 700;
            color: #00ff88;
        }

        .metric-unit {
            font-size: 14px;
            color: #666;
            margin-left: 4px;
        }

        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }

        .status-indicator.disconnected {
            background: #666;
        }

        .status-indicator.connected {
            background: #00ff88;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        #powerBtn:hover { transform: scale(1.15); box-shadow: 0 0 20px #ff3366; background: rgba(255,51,102,0.5); }
        #powerBtn.visible { display: block !important; }

        .hidden {
            display: none !important;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: #666;
        }

        .empty-state svg {
            width: 80px;
            height: 80px;
            margin-bottom: 20px;
            opacity: 0.3;
        }

        @media (max-width:768px){body{padding:10px}h1{font-size:32px}.panel{padding:15px}.workout-item{flex-direction:column}.workout-actions{width:100%;flex-direction:column}.workout-actions .btn{width:100%}.metrics{grid-template-columns:repeat(2,1fr)}.level-grid{grid-template-columns:repeat(5,1fr);gap:6px}.level-btn{padding:8px 4px;font-size:14px}.phase-fields{grid-template-columns:1fr}#powerBtn{top:10px;right:10px;width:45px;height:45px}}@media (max-width:480px){.level-grid{grid-template-columns:repeat(3,1fr)}.metrics{grid-template-columns:1fr}}
    
        .version-footer {
            text-align: center;
            padding: 20px 10px;
            color: #666;
            font-size: 11px;
            margin-top: 30px;
            border-top: 1px solid rgba(255, 255, 255, 0.1);
        }

        .version-footer strong {
            color: #00ff88;
        }

        /* Power button styling */
        #powerBtn {
            font-size: 32px;
        }
        
        #powerBtn:hover {
            background: #ff3366;
            color: #ffffff;
            transform: scale(1.15);
            box-shadow: 0 0 25px rgba(255, 51, 102, 1);
        }

        /* Better mobile responsiveness */
        @media (max-width: 600px) {
            .tabs {
                overflow-x: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .tab {
                flex-shrink: 0;
            }
            
            .workout-actions {
                flex-wrap: wrap;
                gap: 5px;
            }
            
            .workout-actions .btn {
                font-size: 10px;
                padding: 6px 8px;
            }
        }

    
        /* Status indicator dot in top right */
        .status-dot {
            position: fixed;
            top: 15px;
            left: 15px;
            width: 16px;
            height: 16px;
            border-radius: 50%;
            background: #666;
            border: 2px solid rgba(255, 255, 255, 0.3);
            z-index: 1001;
            transition: all 0.3s ease;
        }

        .status-dot.connected {
            background: #00ff88;
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.6);
        }

        .status-dot.disconnected {
            background: #ff3366;
        }

        /* Free ride session controls */
        .session-controls {
            display: flex;
            gap: 15px;
            align-items: center;
            justify-content: center;
        }

        .session-btn {
            width: 60px;
            height: 60px;
            border-radius: 50%;
            border: 3px solid;
            background: rgba(0, 0, 0, 0.3);
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 28px;
            transition: all 0.3s ease;
            flex-shrink: 0;
        }

        .session-btn.play {
            border-color: #00ff88;
            color: #00ff88;
        }

        .session-btn.play:hover {
            background: rgba(0, 255, 136, 0.2);
            transform: scale(1.1);
        }

        .session-btn.pause {
            border-color: #ffaa00;
            color: #ffaa00;
        }

        .session-btn.pause:hover {
            background: rgba(255, 170, 0, 0.2);
            transform: scale(1.1);
        }

        .session-btn.stop {
            border-color: #ff3366;
            color: #ff3366;
        }

        .session-btn.stop:hover {
            background: rgba(255, 51, 102, 0.2);
            transform: scale(1.1);
        }

        .session-btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        .session-timer {
            background: rgba(0, 255, 136, 0.05);
            border: 2px solid rgba(0, 255, 136, 0.3);
            border-radius: 12px;
            padding: 15px 25px;
            min-width: 120px;
            text-align: center;
        }

        .session-timer-label {
            font-size: 11px;
            color: #888;
            margin-bottom: 5px;
            text-transform: uppercase;
        }

        .session-timer-value {
            font-size: 32px;
            font-weight: 700;
            color: #00ff88;
            font-family: 'Courier New', monospace;
        }

    
        .loading-container { text-align: center; padding: 30px 20px; }
        .loading-text { font-size: 18px; color: #00ff88; margin-bottom: 15px; font-weight: 600; }
        .loading-dots { display: flex; justify-content: center; align-items: center; gap: 8px; }
        .loading-dot { width: 12px; height: 12px; background: #00ff88; border-radius: 50%; animation: dotPulse 1.4s infinite ease-in-out; }
        .loading-dot:nth-child(1) { animation-delay: -0.32s; }
        .loading-dot:nth-child(2) { animation-delay: -0.16s; }
        @keyframes dotPulse { 0%, 80%, 100% { transform: scale(0.6); opacity: 0.4; } 40% { transform: scale(1); opacity: 1; } }
        .panel { margin-bottom: 15px; }
        .panel:first-child { margin-top: 0; }
        .simulation-active { border-color: #ffaa00 !important; box-shadow: 0 0 20px rgba(255, 165, 0, 0.3) !important; }
        #simulationToggle.simulation-on { background: rgba(255, 165, 0, 0.3) !important; border-color: #ffaa00 !important; color: #ffaa00 !important; }
</style>
    <!-- PWA Meta Tags -->
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="Zbike 2">
    <meta name="theme-color" content="#0a0e27">
    <meta name="description" content="Sistema Allenamento Completo per Zbike">
    <link rel="manifest" href="manifest.json">
    <link rel="icon" type="image/svg+xml" href="data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'%3E%3Crect fill='%230a0e27' width='100' height='100'/%3E%3Ctext x='50' y='65' font-size='40' text-anchor='middle' fill='%2300ff88' font-family='monospace' font-weight='bold'%3EZ2%3C/text%3E%3C/svg%3E">

    <!-- Service Worker -->
    <script>
        // Suppress Chrome extension errors
        window.addEventListener('error', function(e) {
            if (e.message && e.message.includes('extension')) {
                e.preventDefault();
                return true;
            }
        });
        

        // Service Worker (solo per HTTPS/HTTP, non file://)
        try {
            if ('serviceWorker' in navigator && window.location.protocol !== 'file:') {
                window.addEventListener('load', () => {
                    navigator.serviceWorker.register('sw.js')
                        .then(reg => console.log('‚úÖ SW registered'))
                        .catch(err => console.log('‚ö†Ô∏è SW registration failed:', err));
                });
            }
        } catch(e) {
            console.log('‚ö†Ô∏è SW not available');
        }
    </script>
</head>
<body>
        <!-- Status Indicator Dot -->
    <div class="status-dot disconnected" id="statusDot" title="Disconnesso"></div>

    <div class="container">
        <button id="powerBtn" title="Disconnetti" style="position: fixed; top: 15px; right: 15px; z-index: 999999; width: 44px; height: 44px; background: #ffffff; color: #ff3366; border: 3px solid #ff3366; border-radius: 50%; cursor: pointer; font-size: 32px; font-weight: bold; display: none; font-family: Arial, sans-serif; line-height: 38px; text-align: center; padding: 0; transition: all 0.3s ease; box-shadow: 0 4px 12px rgba(0,0,0,0.5);">√ó</button>

        <div class="header">
            <h1>ZBIKE 2 TRAINER</h1>
            <div class="subtitle">Sistema Allenamento Completo</div>
        </div>

        <!-- Tabs -->
        <div class="tabs">
            <button class="tab active" data-tab="connection">üéöÔ∏è Controllo</button>
            <button class="tab" data-tab="workouts">üö¥ Allenamenti</button>
        </div>

        <!-- Connection + Manual Control Tab -->
        <div class="tab-content active" id="connection-tab">
            <!-- Connection Buttons (Always Visible) -->
            <div class="panel" id="connectionPanel">
                <div id="connectionButtons" style="text-align: center;">
                    <button id="scanBtn" class="btn">üîç SCANSIONA DISPOSITIVO</button>
                    <button id="connectBtn" class="btn" style="display: none;">üîµ CONNETTI</button>
                </div>
                <div id="loadingState" class="loading-container" style="display: none;">
                    <div class="loading-text">Connessione in corso</div>
                    <div class="loading-dots">
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                        <div class="loading-dot"></div>
                    </div>
                </div>
                <div style="text-align: center; margin-top: 15px; padding: 10px; background: rgba(255, 165, 0, 0.1); border: 1px solid rgba(255, 165, 0, 0.3); border-radius: 8px;">
                    <button id="simulationToggle" class="btn secondary" style="font-size: 12px;">üéÆ Modalit√† Simulazione: OFF</button>
                    <div id="simStatus" style="font-size: 10px; color: #888; margin-top: 5px; display: none;">
                        Stato: <span id="simState">Pronta</span> | Ciclo: <span id="simCycle">0</span>/4 | Dist: <span id="simDistance">0.0</span>km
                    </div>
                </div>
            </div>

            <!-- Session Controls (Hidden until connected) -->
            <div class="panel hidden" id="sessionControlsPanel">
                <h2>üö¥ Sessione Libera</h2>
                
                <div style="text-align: center; margin-bottom: 20px;">
                    <button id="startSessionBtn" class="btn">‚ñ∂Ô∏è AVVIA SESSIONE</button>
                </div>
                
                <div id="sessionActiveControls" class="hidden">
                    <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 20px;">
                        <button id="pauseSessionBtn" class="btn small secondary">‚è∏ Pausa</button>
                        <button id="resumeSessionBtn" class="btn small secondary hidden">‚ñ∂Ô∏è Riprendi</button>
                        <button id="stopSessionBtn" class="btn small danger">‚èπ Stop</button>
                    </div>
                    
                    <div class="session-timer" style="text-align: center; margin-bottom: 20px;">
                        <div class="session-timer-label" style="font-size: 12px; color: #888; margin-bottom: 5px;">‚è± TEMPO</div>
                        <div class="session-timer-value" id="sessionTimerDisplay" style="font-size: 24px; font-weight: 700; color: #00ff88;">00:00</div>
                    </div>
                </div>
            </div>

            <div id="metricsPanel" class="panel hidden">
                <h2>üìä Metriche in Tempo Reale</h2>
                <div class="metrics">
                    <div class="metric-card">
                        <div class="metric-label">‚ö° Potenza</div>
                        <div class="metric-value">
                            <span id="powerValue">0</span>
                            <span class="metric-unit">W</span>
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">üîÑ Cadenza</div>
                        <div class="metric-value">
                            <span id="cadenceValue">0</span>
                            <span class="metric-unit">RPM</span>
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">üí® Velocit√†</div>
                        <div class="metric-value">
                            <span id="speedValue">0</span>
                            <span class="metric-unit">km/h</span>
                        </div>
                    </div>
                    <div class="metric-card">
                        <div class="metric-label">üö¥ Distanza</div>
                        <div class="metric-value">
                            <span id="distanceValue">0.0</span>
                            <span class="metric-unit">km</span>
                        </div>
                    </div>
                </div>
            </div>

            <div id="controlPanel" class="panel hidden">
                <h2>üéöÔ∏è Controllo Manuale (Livello: <span id="currentLevel">1</span>/15)</h2>
                <div class="level-grid" id="levelGrid"></div>
            </div>
        </div>

        <!-- Workouts Tab -->
        <div class="tab-content" id="workouts-tab">
            <div class="panel">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 style="margin: 0;">üö¥ I Miei Allenamenti</h2>
                    <button id="newWorkoutBtn" class="btn">+ Nuovo Allenamento</button>
                </div>
                
                <div id="workoutList" class="workout-list">
                    <!-- Workouts will be loaded here -->
                </div>

                <div id="emptyWorkouts" class="empty-state hidden">
                    <div style="font-size: 64px; margin-bottom: 20px;">üö¥</div>
                    <h3 style="color: #888; margin-bottom: 10px;">Nessun allenamento salvato</h3>
                    <p style="color: #666;">Crea il tuo primo allenamento personalizzato!</p>
                </div>
            </div>

            
            <!-- Workout Runner (inline) -->
            <div id="runnerActive" class="panel hidden" style="margin-top: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                    <h2 id="runnerWorkoutName" style="margin: 0; color: #00d4ff;">Allenamento</h2>
                    <button id="stopRunnerBtn" class="btn small danger">‚èπ Stop</button>
                </div>
                
                <div class="workout-runner" style="text-align: center;">
                    <div class="current-phase" style="font-size: 24px; font-weight: 700; color: #00ff88; margin-bottom: 10px;">
                        <div style="font-size: 12px; color: #888; margin-bottom: 5px;">FASE CORRENTE</div>
                        <div id="runnerCurrentPhase">Riscaldamento</div>
                    </div>

                    <div style="font-size: 36px; font-weight: 700; color: #00ff88; margin: 15px 0;">
                        <span id="runnerTimer">05:00</span>
                    </div>

                    <div class="phase-progress" style="background: rgba(0, 0, 0, 0.3); border-radius: 12px; height: 20px; margin: 15px 0; overflow: hidden; position: relative;">
                        <div id="runnerProgressBar" style="height: 100%; background: linear-gradient(90deg, #00ff88 0%, #00d4ff 100%); width: 0%; transition: width 0.3s ease;"></div>
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); font-size: 11px; font-weight: 600;">
                            Fase <span id="runnerPhaseNum">1</span> di <span id="runnerTotalPhases">5</span>
                        </div>
                    </div>

                    <div style="font-size: 12px; color: #888; margin-bottom: 20px;">
                        Prossimo: <strong id="runnerNextPhase" style="color: #00d4ff;">Sprint (Livello 14)</strong>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: center; margin-bottom: 20px;">
                        <button id="pauseBtn" class="btn small secondary">‚è∏ Pausa</button>
                        <button id="resumeBtn" class="btn small secondary hidden">‚ñ∂Ô∏è Riprendi</button>
                        <button id="stopBtn" class="btn small danger">‚èπ Stop</button>
                    </div>

                    <!-- Real-time Metrics during Workout -->
                    <div style="margin-top: 20px; margin-bottom: 20px;">
                        <div style="color: #00ff88; font-size: 13px; font-weight: 600; margin-bottom: 10px; text-align: center;">
                            üìä METRICHE IN TEMPO REALE
                        </div>
                        <div class="metrics">
                            <div class="metric-card">
                                <div class="metric-label">‚ö° Potenza</div>
                                <div class="metric-value">
                                    <span id="runnerPowerValue">0</span>
                                    <span class="metric-unit">W</span>
                                </div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">üîÑ Cadenza</div>
                                <div class="metric-value">
                                    <span id="runnerCadenceValue">0</span>
                                    <span class="metric-unit">RPM</span>
                                </div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">üí® Velocit√†</div>
                                <div class="metric-value">
                                    <span id="runnerSpeedValue">0</span>
                                    <span class="metric-unit">km/h</span>
                                </div>
                            </div>
                            <div class="metric-card">
                                <div class="metric-label">üö¥ Distanza</div>
                                <div class="metric-value">
                                    <span id="runnerDistanceValue">0.0</span>
                                    <span class="metric-unit">km</span>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Power Chart (shown at end of workout) -->
                    <div id="powerChartContainer" class="hidden" style="margin-top: 20px; background: rgba(0, 0, 0, 0.3); border-radius: 12px; padding: 15px;">
                        <h3 style="font-size: 14px; color: #00ff88; margin-bottom: 10px; text-align: center;">üìà Potenza nel Tempo</h3>
                        <canvas id="powerChart" style="max-height: 200px;"></canvas>
                    </div>

                    <!-- Manual Override Controls -->
                    <div style="margin-top: 20px; padding: 15px; background: rgba(255, 170, 0, 0.05); border: 1px solid rgba(255, 170, 0, 0.2); border-radius: 12px;">
                        <div style="color: #ffaa00; font-size: 13px; font-weight: 600; margin-bottom: 10px;">
                            ‚öôÔ∏è Controllo Manuale (Livello: <span id="runnerCurrentLevel">1</span>/15)
                        </div>
                        <div class="level-grid" id="runnerLevelGrid"></div>
                    </div>
                </div>
            </div>

<!-- Workout Editor (hidden by default) -->
            <div id="workoutEditor" class="panel hidden">
                <h2>‚úèÔ∏è <span id="editorTitle">Nuovo Allenamento</span></h2>
                
                <div class="form-group">
                    <label>Nome Allenamento</label>
                    <input type="text" id="workoutName" placeholder="es. HIIT 30min">
                </div>

                <div class="phase-list" id="phaseList">
                    <!-- Phases will be added here -->
                </div>

                <button id="addPhaseBtn" class="btn small secondary">+ Aggiungi Fase</button>

                <div style="margin-top: 30px;">
                    <div style="color: #888; margin-bottom: 15px;">
                        Durata totale: <strong id="totalDuration" style="color: #00ff88;">0 min</strong>
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button id="saveWorkoutBtn" class="btn">üíæ Salva Allenamento</button>
                        <button id="cancelEditBtn" class="btn danger">‚ùå Annulla</button>
                    </div>
                </div>
            </div>
        </div>

        </div>
    </div>

    <script>
        // ===== STATE =====
        // ==================== SIMULATION MODE ====================
        let simulationMode = false;
        let simulationRunning = false;
        let simulationTimer = null;
        let simulationDataTimer = null;
        let simData = { power: 0, cadence: 0, speed: 0, distance: 0 };
        const simPatterns = [{ power: 80, cadence: 85, speed: 25.5 },{ power: 165, cadence: 92, speed: 28.2 },{ power: 250, cadence: 95, speed: 32.1 },{ power: 0, cadence: 0, speed: 0 }];
        let currentPattern = 0;
        function toggleSimulation() {
            const toggleBtn = document.getElementById('simulationToggle');
            const simStatus = document.getElementById('simStatus');
            const powerBtn = document.getElementById('powerBtn');
            
            if (!simulationMode) {
                simulationMode = true;
                toggleBtn.textContent = 'üéÆ Modalit√† Simulazione: ON';
                toggleBtn.classList.add('simulation-on');
                document.querySelector('#connectionPanel').classList.add('simulation-active');
                simStatus.style.display = 'block';
                document.getElementById('sessionControlsPanel').classList.remove('hidden');
                document.getElementById('metricsPanel').classList.remove('hidden');
                document.getElementById('controlPanel').classList.remove('hidden');
                document.querySelectorAll('.level-btn').forEach(btn => btn.disabled = false);
                document.getElementById('playSessionBtn').disabled = false;
                document.getElementById('simState').textContent = 'Pronta';
                
                // Show power button in simulation mode
                if (powerBtn) powerBtn.style.display = 'block';
            } else {
                stopSimulation();
                simulationMode = false;
                toggleBtn.textContent = 'üéÆ Modalit√† Simulazione: OFF';
                toggleBtn.classList.remove('simulation-on');
                document.querySelector('#connectionPanel').classList.remove('simulation-active');
                simStatus.style.display = 'none';
                
                // Hide power button when simulation is off
                if (powerBtn) powerBtn.style.display = 'none';
                
                if (!connected) {
                    document.getElementById('sessionControlsPanel').classList.add('hidden');
                    document.getElementById('metricsPanel').classList.add('hidden');
                    document.getElementById('controlPanel').classList.add('hidden');
                }
            }
        }
        function startSimulation() {
            if (!simulationMode || simulationRunning) return;
            simulationRunning = true;
            simData.distance = totalDistance; // Sync with totalDistance
            currentPattern = -1;
            document.getElementById('simState').textContent = 'In corso';
            simulationLoop();
            simulationTimer = setInterval(simulationLoop, 5000);
            simulationDataTimer = setInterval(updateSimulationData, 1000);
        }
        function pauseSimulation() {
            if (!simulationMode || !simulationRunning) return;
            simulationRunning = false;
            if (simulationTimer) { clearInterval(simulationTimer); simulationTimer = null; }
            if (simulationDataTimer) { clearInterval(simulationDataTimer); simulationDataTimer = null; }
            document.getElementById('simState').textContent = 'Pausa';
        }
        function resumeSimulation() {
            if (!simulationMode || simulationRunning) return;
            simulationRunning = true;
            document.getElementById('simState').textContent = 'In corso';
            simulationTimer = setInterval(simulationLoop, 5000);
            simulationDataTimer = setInterval(updateSimulationData, 1000);
        }
        function stopSimulation() {
            if (!simulationMode) return;
            simulationRunning = false;
            if (simulationTimer) { clearInterval(simulationTimer); simulationTimer = null; }
            if (simulationDataTimer) { clearInterval(simulationDataTimer); simulationDataTimer = null; }
            updateSimData(0, 0, 0);
            simData.distance = 0;
            document.getElementById('distanceValue').textContent = '0.0';
            currentPattern = 0;
            document.getElementById('simState').textContent = 'Pronta';
            document.getElementById('simCycle').textContent = '0';
            document.getElementById('simDistance').textContent = '0.0';
        }
        function simulationLoop() {
            if (!simulationMode || !simulationRunning) return;
            currentPattern = (currentPattern + 1) % simPatterns.length;
            const pattern = simPatterns[currentPattern];
            const power = Math.max(0, pattern.power + (Math.random() - 0.5) * 10);
            const cadence = Math.max(0, pattern.cadence + (Math.random() - 0.5) * 5);
            const speed = Math.max(0, pattern.speed + (Math.random() - 0.5) * 2);
            simData.power = power; simData.cadence = cadence; simData.speed = speed;
            updateSimData(power, cadence, speed);
            document.getElementById('simCycle').textContent = (currentPattern + 1);
        }
        function updateSimulationData() {
            if (!simulationMode || !simulationRunning) return;
            const distanceIncrement = simData.speed / 3600;
            simData.distance += distanceIncrement;
            totalDistance += distanceIncrement; // IMPORTANTE: aggiorna anche totalDistance!
            document.getElementById('distanceValue').textContent = totalDistance.toFixed(2);
            document.getElementById('simDistance').textContent = simData.distance.toFixed(2);
            
            // Update runner distance if in workout
            const runnerDistance = document.getElementById('runnerDistanceValue');
            if (runnerDistance) runnerDistance.textContent = totalDistance.toFixed(2);
        }
        function updateSimData(power, cadence, speed) {
            document.getElementById('powerValue').textContent = Math.round(power);
            document.getElementById('cadenceValue').textContent = Math.round(cadence);
            document.getElementById('speedValue').textContent = speed.toFixed(1);
            
            // Update runner metrics too if workout is active
            const runnerPower = document.getElementById('runnerPowerValue');
            const runnerCadence = document.getElementById('runnerCadenceValue');
            const runnerSpeed = document.getElementById('runnerSpeedValue');
            if (runnerPower) runnerPower.textContent = Math.round(power);
            if (runnerCadence) runnerCadence.textContent = Math.round(cadence);
            if (runnerSpeed) runnerSpeed.textContent = speed.toFixed(1);
            
            // Update power chart in simulation mode
            if (freeRideActive || runningWorkout) {
                updatePowerChart(Math.round(power));
            }
            
            // Update distance in simulation mode
            if ((freeRideActive || runningWorkout) && speed > 0) {
                totalDistance += speed / 3600; // Convert km/h to km traveled in 1 second
                document.getElementById('distanceValue').textContent = totalDistance.toFixed(2);
                const runnerDistance = document.getElementById('runnerDistanceValue');
                if (runnerDistance) runnerDistance.textContent = totalDistance.toFixed(2);
            }
        }
        // ==================== END SIMULATION MODE ====================

        let device = null;
        let server = null;
        let writableChars = [];
        let connected = false;
        let currentPowerLevel = 1;
        let sessionTime = 0;
        let sessionTimer = null;
        let totalDistance = 0;

        // Free ride session state
        let freeRideActive = false;
        let freeRideTimer = null;
        let freeRideTime = 0;
        let freeRidePaused = false;

        // Workout state
        let workouts = [];
        let editingWorkoutId = null;
        let runningWorkout = null;
        let workoutTimer = null;
        let workoutPaused = false;
        let currentPhaseIndex = 0;
        let phaseTimeRemaining = 0;
        let phaseDistanceStart = 0; // Distanza all'inizio della fase (per fasi KM-based)
        let totalWorkoutTime = 0;
        
        // Power chart data
        let powerChartData = {
            labels: [],
            values: []
        };
        let powerChart = null;
        let chartUpdateCounter = 0; // Update chart every N data points for performance

        // Audio context for notifications
        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
        
        function initPowerChart() {
            if (powerChart) return; // Already initialized
            
            console.log('Initializing power chart...');
            const canvas = document.getElementById('powerChart');
            const container = document.getElementById('powerChartContainer');
            
            if (!canvas) {
                console.error('Power chart canvas not found!');
                return;
            }
            
            // Temporarily show container for Chart.js to calculate dimensions
            const wasHidden = container.classList.contains('hidden');
            if (wasHidden) {
                container.classList.remove('hidden');
            }
            
            const ctx = canvas.getContext('2d');
            powerChart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: powerChartData.labels,
                    datasets: [{
                        label: 'Potenza (W)',
                        data: powerChartData.values,
                        borderColor: '#00ff88',
                        backgroundColor: 'rgba(0, 255, 136, 0.1)',
                        borderWidth: 2,
                        tension: 0.4,
                        pointRadius: 0,
                        fill: true
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: {
                            display: false
                        }
                    },
                    scales: {
                        x: {
                            display: false
                        },
                        y: {
                            beginAtZero: true,
                            grid: {
                                color: 'rgba(255, 255, 255, 0.1)'
                            },
                            ticks: {
                                color: '#888',
                                font: {
                                    size: 10
                                }
                            }
                        }
                    },
                    animation: {
                        duration: 0
                    }
                }
            });
            
            // Hide container again if it was hidden
            if (wasHidden) {
                container.classList.add('hidden');
            }
            
            console.log('Power chart initialized successfully');
        }
        
        function updatePowerChart(power) {
            // Lazy init if needed
            if (!powerChart) {
                console.log('Chart not initialized, initializing now...');
                initPowerChart();
                if (!powerChart) {
                    console.error('Failed to initialize power chart!');
                    return;
                }
            }
            
            // Always add data point
            const elapsedSeconds = powerChartData.values.length;
            const mins = Math.floor(elapsedSeconds / 60);
            const secs = elapsedSeconds % 60;
            const timeLabel = `${mins}:${secs.toString().padStart(2, '0')}`;
            
            powerChartData.labels.push(timeLabel);
            powerChartData.values.push(power);
            
            // CRITICAL: Ensure Chart.js references our arrays
            powerChart.data.labels = powerChartData.labels;
            powerChart.data.datasets[0].data = powerChartData.values;
            
            // Log first few data points for debugging
            if (powerChartData.values.length <= 5) {
                console.log('Power chart data point:', powerChartData.values.length, 'power:', power);
            }
            
            // Update chart every 3 seconds for performance (not every data point)
            chartUpdateCounter++;
            if (chartUpdateCounter >= 3) {
                chartUpdateCounter = 0;
                powerChart.update('none'); // 'none' = no animation for better performance
                if (powerChartData.values.length <= 5) {
                    console.log('Chart updated, total points:', powerChartData.values.length);
                }
            }
        }
        
        function resetPowerChart() {
            powerChartData.labels = [];
            powerChartData.values = [];
            chartUpdateCounter = 0;
            if (powerChart) {
                powerChart.update();
            }
        }

        // ===== ELEMENTS =====
        const tabs = document.querySelectorAll('.tab');
        const tabContents = document.querySelectorAll('.tab-content');
        const scanBtn = document.getElementById('scanBtn');
        const connectBtn = document.getElementById('connectBtn');
        const disconnectBtn = document.getElementById('powerBtn'); // Using power button
        const metricsPanel = document.getElementById('metricsPanel');
        const levelGrid = document.getElementById('levelGrid');
        const statusIndicator = document.getElementById('statusIndicator');

        // ===== AUDIO NOTIFICATIONS =====
        function playBeep(frequency = 800, duration = 200) {
            const oscillator = audioContext.createOscillator();
            const gainNode = audioContext.createGain();
            
            oscillator.connect(gainNode);
            gainNode.connect(audioContext.destination);
            
            oscillator.frequency.value = frequency;
            oscillator.type = 'sine';
            
            gainNode.gain.setValueAtTime(0.3, audioContext.currentTime);
            gainNode.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration / 1000);
            
            oscillator.start(audioContext.currentTime);
            oscillator.stop(audioContext.currentTime + duration / 1000);
        }

        function playSkiStartBeeps() {
            // 3 beeps like ski race start countdown
            playBeep(800, 150);  // First beep
            setTimeout(() => playBeep(800, 150), 600);  // Second beep
            setTimeout(() => playBeep(1200, 300), 1200); // Third beep (higher pitch, longer)
        }

        // ===== TAB NAVIGATION =====
        tabs.forEach(tab => {
            tab.addEventListener('click', () => {
                const tabName = tab.dataset.tab;
                
                tabs.forEach(t => t.classList.remove('active'));
                tabContents.forEach(tc => tc.classList.remove('active'));
                
                tab.classList.add('active');
                document.getElementById(`${tabName}-tab`).classList.add('active');
            });
        });

        // ===== BLUETOOTH CONNECTION =====
        // Handle incoming Bluetooth data
        function handleData(event) {
            const value = event.target.value;
            const data = new Uint8Array(value.buffer);
            
            // Log raw data for debugging
            console.log('BLE Data:', Array.from(data).map(b => b.toString(16).padStart(2, '0')).join(' '));
            
            // Determine which service sent the data based on characteristic UUID
            const characteristic = event.target;
            const serviceUUID = characteristic.service.uuid;
            
            console.log('Service UUID:', serviceUUID);
            
            // Parse based on service type
            if (serviceUUID === '00001826-0000-1000-8000-00805f9b34fb' || serviceUUID === '1826') {
                // Fitness Machine Service - Indoor Bike Data
                parseFitnessMachineData(data);
            } else if (serviceUUID === '00001818-0000-1000-8000-00805f9b34fb' || serviceUUID === '1818') {
                // Cycling Power Service
                parseCyclingPowerData(data);
            } else if (serviceUUID === '00001816-0000-1000-8000-00805f9b34fb' || serviceUUID === '1816') {
                // Cycling Speed and Cadence Service
                parseCyclingSpeedCadenceData(data);
            }
        }
        
        function parseFitnessMachineData(data) {
            // Parse based on detected trainer profile
            if (data.length < 13) {
                console.warn('Data too short:', data.length);
                return;
            }
            
            const flags = data[0] | (data[1] << 8);
            console.log('FTMS Flags:', flags.toString(2).padStart(16, '0'), 'Data length:', data.length);
            console.log('Profile:', currentProfile.name);
            
            // Speed - using profile configuration
            const speedRaw = data[currentProfile.speedBytes[0]] | (data[currentProfile.speedBytes[1]] << 8);
            const speed = speedRaw / currentProfile.speedDivisor;
            console.log('Speed:', speed, 'km/h (raw:', speedRaw, 'divisor:', currentProfile.speedDivisor, ')');
            if (speed > 0) updateMetric('speed', speed);
            
            // Cadence - using profile configuration
            const cadenceRaw = data[currentProfile.cadenceBytes[0]] | (data[currentProfile.cadenceBytes[1]] << 8);
            const cadence = cadenceRaw / currentProfile.cadenceDivisor;
            console.log('Cadence:', cadence, 'RPM (raw:', cadenceRaw, ')');
            if (cadence > 0) updateMetric('cadence', cadence);
            
            // Power - using profile configuration
            if (data.length >= (currentProfile.powerBytes[1] + 1)) {
                const power = data[currentProfile.powerBytes[0]] | (data[currentProfile.powerBytes[1]] << 8);
                console.log('Power:', power, 'W (bytes', currentProfile.powerBytes[0], '-', currentProfile.powerBytes[1], ')');
                if (power > 0 && power < 1000) { // Sanity check: max 1000W
                    updateMetric('power', power);
                }
            }
        }
        
        function parseCyclingPowerData(data) {
            // Cycling Power Measurement characteristic
            if (data.length >= 4) {
                const flags = data[0] | (data[1] << 8);
                // Instantaneous Power is always present at bytes 2-3
                const power = data[2] | (data[3] << 8);
                updateMetric('power', power);
            }
        }
        
        function parseCyclingSpeedCadenceData(data) {
            // CSC Measurement characteristic
            if (data.length >= 1) {
                const flags = data[0];
                let index = 1;
                
                // Wheel Revolution Data Present (bit 0)
                if (flags & 0x01 && data.length >= index + 6) {
                    // Could calculate speed from wheel revolutions
                    index += 6;
                }
                
                // Crank Revolution Data Present (bit 1)
                if (flags & 0x02 && data.length >= index + 4) {
                    const crankRevs = data[index] | (data[index + 1] << 8) | (data[index + 2] << 16) | (data[index + 3] << 24);
                    const lastCrankTime = data[index + 4] | (data[index + 5] << 8);
                    // Calculate cadence from crank revolutions
                    // This requires storing previous values to calculate delta
                    // Simplified: just show that data is coming
                }
            }
        }
        
        // ==================== TRAINER PROFILES ====================
        // Different trainers implement FTMS differently
        const trainerProfiles = {
            'zbike2': {
                name: 'Zbike 2',
                patterns: ['zbike', 'z-bike', 'z bike'],
                speedDivisor: 10,  // Speed raw value √∑ 10 = km/h
                cadenceDivisor: 2, // Cadence raw value √∑ 2 = RPM
                powerBytes: [11, 12], // Power at bytes 11-12
                speedBytes: [2, 3],   // Speed at bytes 2-3
                cadenceBytes: [4, 5]  // Cadence at bytes 4-5
            },
            'standard_ftms': {
                name: 'Standard FTMS',
                patterns: ['wahoo', 'tacx', 'elite', 'saris', 'kinetic', 'jetblack'],
                speedDivisor: 100, // Standard FTMS: √∑100
                cadenceDivisor: 2,
                powerBytes: [6, 7], // Standard position
                speedBytes: [2, 3],
                cadenceBytes: [4, 5]
            }
        };
        
        let currentProfile = trainerProfiles.zbike2; // Default
        
        function detectTrainerProfile(deviceName) {
            const nameLower = deviceName.toLowerCase();
            
            // Check each profile
            for (const [key, profile] of Object.entries(trainerProfiles)) {
                for (const pattern of profile.patterns) {
                    if (nameLower.includes(pattern)) {
                        console.log(`‚úÖ Detected trainer: ${profile.name}`);
                        return profile;
                    }
                }
            }
            
            // Default to standard FTMS if unknown
            console.log('‚ö†Ô∏è Unknown trainer, using Standard FTMS profile');
            return trainerProfiles.standard_ftms;
        }
        
        // Variables for distance calculation
        let lastSpeedUpdate = Date.now();
        let lastSpeed = 0;
        
        function updateMetric(type, value) {
            if (type === 'power') {
                document.getElementById('powerValue').textContent = Math.round(value);
                const runnerPower = document.getElementById('runnerPowerValue');
                if (runnerPower) runnerPower.textContent = Math.round(value);
                
                // Update power chart
                if (freeRideActive || runningWorkout) {
                    updatePowerChart(Math.round(value));
                }
            } else if (type === 'cadence') {
                document.getElementById('cadenceValue').textContent = Math.round(value);
                const runnerCadence = document.getElementById('runnerCadenceValue');
                if (runnerCadence) runnerCadence.textContent = Math.round(value);
            } else if (type === 'speed') {
                document.getElementById('speedValue').textContent = value.toFixed(1);
                const runnerSpeed = document.getElementById('runnerSpeedValue');
                if (runnerSpeed) runnerSpeed.textContent = value.toFixed(1);
                
                // Update distance using real time delta (for Bluetooth real data)
                if (freeRideActive || runningWorkout) {
                    const now = Date.now();
                    const deltaSeconds = (now - lastSpeedUpdate) / 1000;
                    
                    // Use average speed between updates for accuracy
                    const avgSpeed = (value + lastSpeed) / 2;
                    const distanceIncrement = (avgSpeed * deltaSeconds) / 3600; // km/h * hours = km
                    
                    totalDistance += distanceIncrement;
                    document.getElementById('distanceValue').textContent = totalDistance.toFixed(2);
                    const runnerDistance = document.getElementById('runnerDistanceValue');
                    if (runnerDistance) runnerDistance.textContent = totalDistance.toFixed(2);
                    
                    lastSpeedUpdate = now;
                    lastSpeed = value;
                }
            }
        }

        async function scanDevices() {
            try {
                device = await navigator.bluetooth.requestDevice({
                    acceptAllDevices: true,
                    optionalServices: [0x1826, 0x1816, 0x1818, 'battery_service']
                });

                setupDeviceListeners();

                scanBtn.style.display = 'none';
                connectBtn.style.display = 'inline-block';
                
                // Auto-connect immediately
                await connectDevice();
                
            } catch (error) {
                console.error('Scan error:', error);
                scanBtn.style.display = 'inline-block';
                connectBtn.style.display = 'none';
            }
        

        // Add disconnect listener when device is selected
        function setupDeviceListeners() {
            if (device) {
                device.addEventListener('gattserverdisconnected', () => {
                    console.log('‚ö†Ô∏è Device disconnected unexpectedly');
                    connected = false;
                    updateConnectionUI();
                    
                    // Stop any active sessions
                    if (freeRideActive) {
                        stopFreeRide();
                    }
                    if (runningWorkout) {
                        stopWorkout();
                    }
                });
            }
        }
}

        async function connectDevice() {
            const cb=document.getElementById("connectionButtons");const ls=document.getElementById("loadingState");const cp=document.getElementById("connectionPanel");if(cb&&ls){cb.style.display="none";ls.style.display="block";}
            try {
                console.log('Connecting to device...');
                
                // Multiple connection attempts with retry
                let attempts = 0;
                const maxAttempts = 3;
                
                while (attempts < maxAttempts) {
                    try {
                        // Check if device exists
                        if (!device) {
                            throw new Error('Nessun dispositivo selezionato');
                        }
                        
                        // Check if already connected
                        if (device.gatt.connected) {
                            console.log('Already connected, disconnecting first...');
                            await device.gatt.disconnect();
                            await new Promise(resolve => setTimeout(resolve, 500));
                        }
                        
                        // Connect
                        console.log(`Connection attempt ${attempts + 1}/${maxAttempts}...`);
                        server = await device.gatt.connect();
                        
                        // Verify connection
                        if (!server || !server.connected) {
                            throw new Error('Server not connected after connection attempt');
                        }
                        
                        console.log('Connected! Getting services...');
                        
                        // Detect trainer profile based on device name
                        currentProfile = detectTrainerProfile(device.name || '');
                        console.log(`üì± Device: ${device.name}`);
                        console.log(`‚úÖ Using profile: ${currentProfile.name}`);
                        
                        // Small delay to ensure connection is stable
                        await new Promise(resolve => setTimeout(resolve, 300));
                        
                        // Get services
                        const services = await server.getPrimaryServices();
                        console.log(`Found ${services.length} services`);
                        
                        writableChars = [];
                        
                        for (const service of services) {
                            try {
                                const chars = await service.getCharacteristics();
                                
                                for (const char of chars) {
                                    if (char.properties.write || char.properties.writeWithoutResponse) {
                                        writableChars.push({ char, service: service.uuid });
                                    }
                                    
                                    if (char.properties.notify) {
                                        try {
                                            await char.startNotifications();
                                            char.addEventListener('characteristicvaluechanged', handleData);
                                        } catch (e) {
                                            console.log('Notification error:', e);
                                        }
                                    }
                                }
                            } catch (e) {
                                console.log('Service error:', e);
                            }
                        }

                        connected = true;
                        if(cb&&ls){cb.style.display="none";ls.style.display="none";}if(cp){cp.style.display="none";}
                        updateConnectionUI();
                        startSession();
                        requestWakeLock(); // Keep screen on during connection
                        
                        console.log('‚úÖ Connection successful!');
                        return; // Success!
                        
                    } catch (attemptError) {
                        attempts++;
                        console.error(`Connection attempt ${attempts} failed:`, attemptError);
                        
                        if (attempts < maxAttempts) {
                            console.log('Retrying in 1 second...');
                            await new Promise(resolve => setTimeout(resolve, 1000));
                        } else {
                            throw attemptError; // Max attempts reached
                        }
                    }
                }
                
            } catch (error) {
                console.error('Connection error:', error);
                alert('Errore connessione: ' + error.message + '\n\nProva a:\n1. Riavviare Zbike\n2. Disabilitare/riabilitare Bluetooth\n3. Ricaricare la pagina');
                if(cb&&ls){cb.style.display="block";ls.style.display="none";}if(cp){cp.style.display="block";}
                scanBtn.style.display = 'inline-block';
                connectBtn.style.display = 'none';
            }
        }

        
        async function disconnectDevice() {
            // If in simulation mode, turn it off
            if (simulationMode) {
                // Stop any active workout or free ride before turning off simulation
                if (runningWorkout) {
                    stopWorkoutSilent(); // Stop without confirmation
                }
                if (freeRideActive) {
                    stopFreeRideSilent(); // Stop without confirmation
                }
                toggleSimulation();
                return;
            }
            
            // Stop any active sessions before disconnecting
            if (runningWorkout) {
                stopWorkoutSilent(); // Stop without confirmation
            }
            if (freeRideActive) {
                stopFreeRideSilent(); // Stop without confirmation
            }
            
            // Otherwise disconnect real device
            if (server && server.connected) {
                await server.disconnect();
            }
            connected = false;
            device = null;
            server = null;
            writableChars = [];
            releaseWakeLock();
            stopSession();
            totalDistance = 0;
            document.getElementById('distanceValue').textContent = '0.0';
            updateConnectionUI();
            
            scanBtn.style.display = 'inline-block';
            connectBtn.style.display = 'none';
        }

        function updateConnectionUI() {
            const statusDot = document.getElementById('statusDot');
            
            if (connected) {
                // Status dot
                statusDot.classList.remove('disconnected');
                statusDot.classList.add('connected');
                statusDot.title = 'Connesso';
                
                // Buttons
                // disconnectBtn shown (power button)
                connectBtn.style.display = 'none';
                scanBtn.style.display = 'none';
                
                // Show session controls
                const sessionPanel = document.getElementById('sessionControlsPanel');
                if (sessionPanel) sessionPanel.classList.remove('hidden');
                
                
                // Panels
                metricsPanel.classList.remove('hidden');
                document.getElementById('controlPanel').classList.remove('hidden');
                document.querySelectorAll('.level-btn').forEach(btn => btn.disabled = false);
                
                // Power button
                var pb = document.getElementById('powerBtn'); 
                if(pb) pb.style.display = 'block';
            } else {
                const cpUpdate = document.getElementById("connectionPanel");const cbUpdate = document.getElementById("connectionButtons");const lsUpdate = document.getElementById("loadingState");if(cpUpdate&&!simulationMode)cpUpdate.style.display="block";if(cbUpdate)cbUpdate.style.display="block";if(lsUpdate)lsUpdate.style.display="none";
                document.querySelectorAll(".tab").forEach(t => t.classList.remove("active"));document.querySelectorAll(".tab-content").forEach(tc => tc.classList.remove("active"));document.querySelector('.tab[data-tab="connection"]').classList.add("active");document.getElementById("connection-tab").classList.add("active");
                // Status dot
                statusDot.classList.remove('connected');
                statusDot.classList.add('disconnected');
                statusDot.title = 'Disconnesso';
                
                // Buttons
                // disconnectBtn hidden (power button)
                scanBtn.style.display = 'inline-block';
                
                // Disable play button
                playBtn.disabled = true;
                
                // Hide session controls
                const sessionPanel = document.getElementById('sessionControlsPanel');
                if (sessionPanel) sessionPanel.classList.add('hidden');
                
                
                // Stop any active session
                if (freeRideActive) {
                    stopFreeRide();
                }
                
                // Panels
                metricsPanel.classList.add('hidden');
                document.getElementById('controlPanel').classList.add('hidden');
                document.querySelectorAll('.level-btn').forEach(btn => btn.disabled = true);
                
                // Power button
                var pb2 = document.getElementById('powerBtn'); 
                if(pb2) pb2.style.display = 'none';
            }
        }

        function startSession() {
            sessionTime = 0;
            sessionTimer = setInterval(() => {
                sessionTime++;
                const mins = Math.floor(sessionTime / 60);
                const secs = sessionTime % 60;
                // document.getElementById('timeValue').textContent = 
                    `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
            }, 1000);
        }

        function stopSession() {
            if (sessionTimer) {
                clearInterval(sessionTimer);
                sessionTimer = null;
            }
            sessionTime = 0;
            
            // Reset metrics
            document.getElementById('powerValue').textContent = '0';
            document.getElementById('cadenceValue').textContent = '0';
            document.getElementById('speedValue').textContent = '0';
            document.getElementById('distanceValue').textContent = '0.0';
            
            // Reset runner metrics if they exist
            const runnerPower = document.getElementById('runnerPowerValue');
            const runnerCadence = document.getElementById('runnerCadenceValue');
            const runnerSpeed = document.getElementById('runnerSpeedValue');
            const runnerDistance = document.getElementById('runnerDistanceValue');
            if (runnerPower) runnerPower.textContent = '0';
            if (runnerCadence) runnerCadence.textContent = '0';
            if (runnerSpeed) runnerSpeed.textContent = '0';
            if (runnerDistance) runnerDistance.textContent = '0.0';
            
            totalDistance = 0;
        }

        // ===== MANUAL CONTROL =====
        function getEstimatedWatts(level) {
            // Distribuzione personalizzata dei watt per livello
            const wattsMap = {
                1: 40,   // Livello 1
                2: 80,   // Livello 2
                3: 120,  // Livello 3
                4: 140,  // Livello 4
                5: 165,  // Livello 5 (era al livello 4)
                6: 190,  // Livello 6
                7: 210,  // Livello 7
                8: 230,  // Livello 8
                9: 245,  // Livello 9
                10: 260, // Livello 10
                11: 270, // Livello 11
                12: 280, // Livello 12
                13: 285, // Livello 13
                14: 290, // Livello 14
                15: 300  // Livello 15
            };
            return wattsMap[level] || 40;
        }

        function initLevelButtons() {
            // Main control tab level grid
            for (let i = 1; i <= 15; i++) {
                const btn = document.createElement('button');
                btn.className = 'level-btn';
                
                const watts = getEstimatedWatts(i);
                btn.innerHTML = `<div style="font-size: 18px; font-weight: 700;">${i}</div>
                                 <div style="font-size: 11px; opacity: 0.6; margin-top: 3px;">~${watts}W</div>`;
                
                btn.disabled = true;
                btn.dataset.level = i;
                btn.onclick = () => changePowerLevel(i);
                if (i === 1) btn.classList.add('active');
                levelGrid.appendChild(btn);
            }
            
            // Runner tab level grid (for manual override)
            const runnerLevelGrid = document.getElementById('runnerLevelGrid');
            for (let i = 1; i <= 15; i++) {
                const btn = document.createElement('button');
                btn.className = 'level-btn runner-level-btn';
                
                const watts = getEstimatedWatts(i);
                btn.innerHTML = `<div style="font-size: 16px; font-weight: 700;">${i}</div>
                                 <div style="font-size: 10px; opacity: 0.6; margin-top: 2px;">~${watts}W</div>`;
                
                btn.dataset.level = i;
                btn.onclick = () => manualOverrideLevel(i);
                runnerLevelGrid.appendChild(btn);
            }
        }

        async function changePowerLevel(level) {
            currentPowerLevel = level;
            document.getElementById('currentLevel').textContent = level;
            
            document.querySelectorAll('.level-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.level) === level) {
                    btn.classList.add('active');
                }
            });
            
            // In simulation mode, update simulated power based on level
            if (simulationMode) {
                // Update simulation pattern based on level
                const estimatedWatts = getEstimatedWatts(level);
                // Adjust simulation data to match the level
                simData.power = estimatedWatts * 0.9; // Base power for this level
                return;
            }
            
            // Real device control
            if (!connected || writableChars.length === 0) return;
            
            const resistance = Math.round(10 + ((level - 1) / 14) * 140);
            
            for (const item of writableChars) {
                try {
                    await item.char.writeValue(new Uint8Array([0x04, resistance]));
                } catch (e) {}
                
                try {
                    await item.char.writeValue(new Uint8Array([resistance]));
                } catch (e) {}
            }
        }

        async function manualOverrideLevel(level) {
            if (!connected && !simulationMode) return;
            if (!runningWorkout && !simulationMode) return;
            
            // Update runner level buttons visual state
            document.querySelectorAll('.runner-level-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.level) === level) {
                    btn.classList.add('active');
                }
            });
            
            // Set the resistance
            await changePowerLevel(level);
            
            // Update runner display
            document.getElementById('runnerCurrentLevel').textContent = level;
        }

        // ===== WORKOUT MANAGEMENT =====
        function loadWorkouts() {
            try {
                const saved = localStorage.getItem('zbike_workouts');
                workouts = saved ? JSON.parse(saved) : [];
            } catch (e) {
                workouts = [];
            }
            renderWorkoutList();
        }

        function saveWorkouts() {
            try {
                localStorage.setItem('zbike_workouts', JSON.stringify(workouts));
            } catch (e) {}
        }

        function renderWorkoutList() {
            const list = document.getElementById('workoutList');
            const empty = document.getElementById('emptyWorkouts');
            
            if (workouts.length === 0) {
                list.innerHTML = '';
                empty.classList.remove('hidden');
                return;
            }
            
            empty.classList.add('hidden');
            list.innerHTML = workouts.map(workout => {
                const totalMin = Math.round(workout.phases.reduce((sum, p) => sum + p.duration, 0) / 60);
                return `
                    <div class="workout-item">
                        <div class="workout-info">
                            <h3>${workout.name}</h3>
                            <div class="workout-meta">
                                ${workout.phases.length} fasi ‚Ä¢ ${totalMin} minuti
                            </div>
                        </div>
                        <div class="workout-actions">
                            <button class="btn small secondary" onclick="startWorkout('${workout.id}')">‚ñ∂Ô∏è Inizia</button>
                            <button class="btn small" onclick="editWorkout('${workout.id}')">‚úèÔ∏è Modifica</button>
                            <button class="btn small danger" onclick="deleteWorkout('${workout.id}')">üóëÔ∏è</button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function newWorkout() {
            editingWorkoutId = null;
            document.getElementById('editorTitle').textContent = 'Nuovo Allenamento';
            document.getElementById('workoutName').value = '';
            document.getElementById('phaseList').innerHTML = '';
            document.getElementById('workoutEditor').classList.remove('hidden');
            addPhase();
        }

        function editWorkout(id) {
            const workout = workouts.find(w => w.id === id);
            if (!workout) return;
            
            editingWorkoutId = id;
            document.getElementById('editorTitle').textContent = 'Modifica Allenamento';
            document.getElementById('workoutName').value = workout.name;
            
            const phaseList = document.getElementById('phaseList');
            phaseList.innerHTML = '';
            
            // Reconstruct intervals from expanded phases
            const reconstructedPhases = [];
            let i = 0;
            while (i < workout.phases.length) {
                const phase = workout.phases[i];
                
                // Check if this looks like an interval pattern
                if (phase.type === 'interval-work' && i + 1 < workout.phases.length) {
                    const nextPhase = workout.phases[i + 1];
                    if (nextPhase.type === 'interval-rest') {
                        // Count how many times this pattern repeats
                        let repeats = 1;
                        let j = i + 2;
                        while (j + 1 < workout.phases.length) {
                            const checkWork = workout.phases[j];
                            const checkRest = workout.phases[j + 1];
                            if (checkWork.type === 'interval-work' && checkRest.type === 'interval-rest' &&
                                checkWork.duration === phase.duration && checkWork.level === phase.level &&
                                checkRest.duration === nextPhase.duration && checkRest.level === nextPhase.level) {
                                repeats++;
                                j += 2;
                            } else {
                                break;
                            }
                        }
                        
                        // Create interval phase
                        reconstructedPhases.push({
                            type: 'interval',
                            workDuration: phase.duration,
                            workLevel: phase.level,
                            restDuration: nextPhase.duration,
                            restLevel: nextPhase.level,
                            repeats: repeats
                        });
                        
                        i = i + (repeats * 2);
                        continue;
                    }
                }
                
                // Normal phase
                reconstructedPhases.push(phase);
                i++;
            }
            
            // Add phases to UI
            reconstructedPhases.forEach(phase => {
                addPhase(phase);
            });
            
            document.getElementById('workoutEditor').classList.remove('hidden');
            updateTotalDuration();
        }

        function deleteWorkout(id) {
            if (!confirm('Sei sicuro di voler eliminare questo allenamento?')) return;
            
            workouts = workouts.filter(w => w.id !== id);
            saveWorkouts();
            renderWorkoutList();
        }

        function addPhase(phase = null) {
            const phaseList = document.getElementById('phaseList');
            const phaseNum = phaseList.children.length + 1;
            
            const isInterval = phase && phase.type === 'interval';
            const durationMode = phase && phase.isKmBased ? 'distance' : 'time';
            
            // Calculate display value based on mode
            let durationValue = '';
            if (phase && !isInterval) {
                if (phase.isKmBased) {
                    durationValue = phase.duration; // Already in KM
                } else {
                    durationValue = phase.duration / 60; // Convert seconds to minutes
                }
            }
            
            const phaseDiv = document.createElement('div');
            phaseDiv.className = 'phase-item';
            phaseDiv.innerHTML = `
                <div class="phase-header">
                    <div class="phase-title">Fase ${phaseNum}</div>
                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                        <select class="phase-type" onchange="toggleIntervalFields(this)" style="padding: 4px 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 6px; font-size: 11px;">
                            <option value="normal" ${!isInterval ? 'selected' : ''}>Fase Normale</option>
                            <option value="interval" ${isInterval ? 'selected' : ''}>Ripetuta</option>
                        </select>
                        <button class="btn small danger" onclick="this.closest('.phase-item').remove(); updateTotalDuration();">üóëÔ∏è</button>
                    </div>
                </div>
                
                <!-- Normal Phase Fields -->
                <div class="normal-fields" style="display: ${isInterval ? 'none' : 'block'};">
                    <div class="phase-fields">
                        <div class="form-group" style="margin: 0;">
                            <input type="text" class="phase-name" placeholder="Nome fase" value="${phase && !isInterval ? phase.name : ''}" style="font-size: 12px; padding: 8px;">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <select class="duration-mode" onchange="toggleDurationMode(this)" style="padding: 8px; background: rgba(0,0,0,0.3); border: 1px solid rgba(255,255,255,0.2); color: #fff; border-radius: 6px; font-size: 11px;">
                                <option value="time" ${durationMode === 'time' ? 'selected' : ''}>‚è±Ô∏è Min</option>
                                <option value="distance" ${durationMode === 'distance' ? 'selected' : ''}>üö¥ Km</option>
                            </select>
                        </div>
                        <div class="form-group" style="margin: 0;" class="duration-input-container">
                            <input type="number" class="phase-duration" placeholder="${durationMode === 'time' ? 'Min' : 'Km'}" min="0.1" step="0.1" value="${durationValue}" onchange="updateTotalDuration()" style="font-size: 12px; padding: 8px;">
                        </div>
                        <div class="form-group" style="margin: 0;">
                            <select class="phase-level" onchange="updateTotalDuration()" style="padding: 8px; font-size: 11px;">
                                ${Array.from({length: 15}, (_, i) => {
                                    const level = i + 1;
                                    const watts = getEstimatedWatts(level);
                                    const selected = phase && !isInterval && phase.level === level ? 'selected' : '';
                                    return `<option value="${level}" ${selected}>Lv.${level} (~${watts}W)</option>`;
                                }).join('')}
                            </select>
                        </div>
                    </div>
                </div>
                
                <!-- Interval Fields -->
                <div class="interval-fields" style="display: ${isInterval ? 'block' : 'none'};">
                    <div style="background: rgba(0, 212, 255, 0.05); border: 1px solid rgba(0, 212, 255, 0.2); border-radius: 8px; padding: 10px; margin-top: 10px;">
                        <div style="color: #00d4ff; font-size: 11px; font-weight: 600; margin-bottom: 10px; text-transform: uppercase;">
                            üîÅ Ripetuta
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 10px; color: #00d4ff;">Lavoro (sec)</label>
                                <input type="number" class="interval-work-duration" placeholder="30" min="5" value="${isInterval ? phase.workDuration : ''}" onchange="updateTotalDuration()" style="font-size: 11px; padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 10px; color: #00d4ff;">Liv. Lavoro</label>
                                <select class="interval-work-level" onchange="updateTotalDuration()" style="padding: 6px; font-size: 10px;">
                                    ${Array.from({length: 15}, (_, i) => {
                                        const level = i + 1;
                                        const watts = getEstimatedWatts(level);
                                        let selected = '';
                                        if (isInterval && phase.workLevel !== undefined) {
                                            // Use saved value
                                            selected = phase.workLevel === level ? 'selected' : '';
                                        } else if (!isInterval && level === 12) {
                                            // Default for new intervals
                                            selected = 'selected';
                                        }
                                        return `<option value="${level}" ${selected}>Lv.${level} (~${watts}W)</option>`;
                                    }).join('')}
                                </select>
                            </div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 10px; color: #00d4ff;">Recupero (sec)</label>
                                <input type="number" class="interval-rest-duration" placeholder="30" min="5" value="${isInterval ? phase.restDuration : ''}" onchange="updateTotalDuration()" style="font-size: 11px; padding: 6px;">
                            </div>
                            <div class="form-group" style="margin: 0;">
                                <label style="font-size: 10px; color: #00d4ff;">Liv. Recupero</label>
                                <select class="interval-rest-level" onchange="updateTotalDuration()" style="padding: 6px; font-size: 10px;">
                                    ${Array.from({length: 15}, (_, i) => {
                                        const level = i + 1;
                                        const watts = getEstimatedWatts(level);
                                        let selected = '';
                                        if (isInterval && phase.restLevel !== undefined) {
                                            // Use saved value
                                            selected = phase.restLevel === level ? 'selected' : '';
                                        } else if (!isInterval && level === 4) {
                                            // Default for new intervals
                                            selected = 'selected';
                                        }
                                        return `<option value="${level}" ${selected}>Lv.${level} (~${watts}W)</option>`;
                                    }).join('')}
                                </select>
                            </div>
                        </div>
                        
                        <div class="form-group" style="margin: 0;">
                            <label style="font-size: 10px; color: #00d4ff;">N¬∞ Ripetizioni</label>
                            <input type="number" class="interval-repeats" placeholder="5" min="1" value="${isInterval ? phase.repeats : '5'}" onchange="updateTotalDuration()" style="font-size: 11px; padding: 6px;">
                        </div>
                        
                        <div style="margin-top: 8px; padding: 8px; background: rgba(0,0,0,0.3); border-radius: 6px; font-size: 10px; color: #888;">
                            <span class="interval-preview">30s Lv.12 + 30s Lv.4, x5 = 5 min</span>
                        </div>
                    </div>
                </div>
            `;
            
            phaseList.appendChild(phaseDiv);
            
            // Add event listeners for interval preview
            const fields = phaseDiv.querySelectorAll('.interval-work-duration, .interval-rest-duration, .interval-repeats, .interval-work-level, .interval-rest-level');
            fields.forEach(field => {
                field.addEventListener('input', () => updateIntervalPreview(phaseDiv));
            });
            
            if (isInterval) {
                updateIntervalPreview(phaseDiv);
            }
            
            updateTotalDuration();
        }

        function toggleDurationMode(select) {
            const container = select.closest('.normal-fields');
            const durationInput = container.querySelector('.phase-duration');
            
            if (select.value === 'distance') {
                durationInput.placeholder = 'Km';
                durationInput.step = '0.1';
            } else {
                durationInput.placeholder = 'Min';
                durationInput.step = '0.5';
            }
            
            updateTotalDuration();
        }

        function toggleIntervalFields(select) {
            const phaseItem = select.closest('.phase-item');
            const normalFields = phaseItem.querySelector('.normal-fields');
            const intervalFields = phaseItem.querySelector('.interval-fields');
            
            if (select.value === 'interval') {
                normalFields.style.display = 'none';
                intervalFields.style.display = 'block';
                updateIntervalPreview(phaseItem);
            } else {
                normalFields.style.display = 'block';
                intervalFields.style.display = 'none';
            }
            
            updateTotalDuration();
        }

        function updateIntervalPreview(phaseDiv) {
            const workDur = parseInt(phaseDiv.querySelector('.interval-work-duration').value) || 0;
            const restDur = parseInt(phaseDiv.querySelector('.interval-rest-duration').value) || 0;
            const repeats = parseInt(phaseDiv.querySelector('.interval-repeats').value) || 0;
            const workLevel = parseInt(phaseDiv.querySelector('.interval-work-level').value) || 1;
            const restLevel = parseInt(phaseDiv.querySelector('.interval-rest-level').value) || 1;
            
            const totalSec = (workDur + restDur) * repeats;
            const totalMin = (totalSec / 60).toFixed(1);
            
            const preview = phaseDiv.querySelector('.interval-preview');
            if (preview) {
                preview.textContent = `${workDur}s a Lv.${workLevel} + ${restDur}s a Lv.${restLevel}, ripeti ${repeats} volte = ${totalMin} min totali`;
            }
        }

        function updateTotalDuration() {
            const phases = document.querySelectorAll('.phase-item');
            let total = 0;
            
            phases.forEach((phase, index) => {
                const title = phase.querySelector('.phase-title');
                title.textContent = `Fase ${index + 1}`;
                
                const phaseType = phase.querySelector('.phase-type').value;
                
                if (phaseType === 'interval') {
                    // Calcola durata ripetute
                    const workDur = parseFloat(phase.querySelector('.interval-work-duration').value) || 0;
                    const restDur = parseFloat(phase.querySelector('.interval-rest-duration').value) || 0;
                    const repeats = parseInt(phase.querySelector('.interval-repeats').value) || 0;
                    
                    // Totale in secondi, poi converti in minuti
                    const totalSeconds = (workDur + restDur) * repeats;
                    total += totalSeconds / 60;
                } else {
                    // Fase normale
                    const duration = parseFloat(phase.querySelector('.phase-duration').value) || 0;
                    total += duration;
                }
            });
            
            document.getElementById('totalDuration').textContent = `${total.toFixed(1)} min`;
        }

        function saveWorkout() {
            const name = document.getElementById('workoutName').value.trim();
            if (!name) {
                alert('Inserisci un nome per l\'allenamento');
                return;
            }
            
            const phaseElements = document.querySelectorAll('.phase-item');
            if (phaseElements.length === 0) {
                alert('Aggiungi almeno una fase');
                return;
            }
            
            const phases = [];
            
            // Process each phase
            phaseElements.forEach(el => {
                const phaseType = el.querySelector('.phase-type').value;
                
                if (phaseType === 'interval') {
                    // Interval phase - expand into multiple work/rest phases
                    const workDur = parseInt(el.querySelector('.interval-work-duration').value) || 0;
                    const restDur = parseInt(el.querySelector('.interval-rest-duration').value) || 0;
                    const repeats = parseInt(el.querySelector('.interval-repeats').value) || 0;
                    const workLevel = parseInt(el.querySelector('.interval-work-level').value);
                    const restLevel = parseInt(el.querySelector('.interval-rest-level').value);
                    
                    if (workDur <= 0 || restDur <= 0 || repeats <= 0) {
                        return; // Skip invalid intervals
                    }
                    
                    // Add each repeat as separate work/rest phases
                    for (let i = 0; i < repeats; i++) {
                        phases.push({
                            name: `Lavoro ${i + 1}/${repeats}`,
                            duration: workDur,
                            level: workLevel,
                            type: 'interval-work'
                        });
                        phases.push({
                            name: `Recupero ${i + 1}/${repeats}`,
                            duration: restDur,
                            level: restLevel,
                            type: 'interval-rest'
                        });
                    }
                } else {
                    // Normal phase
                    const name = el.querySelector('.phase-name').value.trim() || 'Fase';
                    const durationMode = el.querySelector('.duration-mode').value;
                    const durationValue = parseFloat(el.querySelector('.phase-duration').value) || 0;
                    const level = parseInt(el.querySelector('.phase-level').value);
                    
                    if (durationValue <= 0) {
                        return; // Skip invalid phases
                    }
                    
                    const phaseData = {
                        name,
                        level,
                        type: 'normal'
                    };
                    
                    if (durationMode === 'distance') {
                        // Distance-based phase
                        phaseData.isKmBased = true;
                        phaseData.duration = durationValue; // Store KM value in duration field
                    } else {
                        // Time-based phase
                        phaseData.isKmBased = false;
                        phaseData.duration = Math.round(durationValue * 60); // Convert minutes to seconds
                    }
                    
                    phases.push(phaseData);
                }
            });
            
            if (phases.length === 0) {
                alert('Tutte le fasi devono avere una durata maggiore di 0');
                return;
            }
            
            const workout = {
                id: editingWorkoutId || Date.now().toString(),
                name,
                phases
            };
            
            if (editingWorkoutId) {
                const index = workouts.findIndex(w => w.id === editingWorkoutId);
                workouts[index] = workout;
            } else {
                workouts.push(workout);
            }
            
            saveWorkouts();
            renderWorkoutList();
            cancelEdit();
            
            playBeep(1000, 200);
        }

        function cancelEdit() {
            document.getElementById('workoutEditor').classList.add('hidden');
            editingWorkoutId = null;
        }

        // ===== WORKOUT RUNNER =====
        function startWorkout(id) {
            if (!connected && !simulationMode) {
                alert('Connetti prima il dispositivo!');
                return;
            }
            
            const workout = workouts.find(w => w.id === id);
            if (!workout) return;
            
            runningWorkout = workout;
            currentPhaseIndex = 0;
            totalWorkoutTime = 0;
            totalDistance = 0;
            workoutPaused = false;
            lastSpeedUpdate = Date.now(); // Reset for distance calculation
            lastSpeed = 0;
            
            // Reset distance display
            document.getElementById('runnerDistanceValue').textContent = '0.0';
            
            // Reset power chart and initialize if needed
            resetPowerChart();
            if (!powerChart) {
                console.log('Initializing chart at workout start...');
                initPowerChart();
            }
            document.getElementById('powerChartContainer').classList.add('hidden');
            
            // Keep screen on during workout
            requestWakeLock();
            
            // Switch to runner tab
            
            // Setup UI
            document.getElementById('workoutList').style.display = 'none';
            document.getElementById('emptyWorkouts').style.display = 'none';
            document.getElementById('newWorkoutBtn').style.display = 'none';
            document.getElementById('runnerActive').classList.remove('hidden');
            document.getElementById('runnerWorkoutName').textContent = workout.name;
            document.getElementById('runnerTotalPhases').textContent = workout.phases.length;
            
            // Start first phase with countdown beeps
            playSkiStartBeeps();
            setTimeout(() => startPhase(0), 2000); // Start after beeps finish
            
            // Start timer
            workoutTimer = setInterval(updateWorkoutRunner, 1000);
        if (simulationMode && !simulationRunning) { startSimulation(); }
        }

        function startPhase(index) {
            if (index >= runningWorkout.phases.length) {
                finishWorkout();
                return;
            }
            
            currentPhaseIndex = index;
            const phase = runningWorkout.phases[index];
            phaseTimeRemaining = 0; // Start from 0 and count up
            phaseDistanceStart = totalDistance; // Save current distance for KM-based phases
            
            // Update UI
            document.getElementById('runnerCurrentPhase').textContent = phase.name;
            document.getElementById('runnerPhaseNum').textContent = index + 1;
            document.getElementById('runnerCurrentLevel').textContent = phase.level;
            
            // Update runner level buttons
            document.querySelectorAll('.runner-level-btn').forEach(btn => {
                btn.classList.remove('active');
                if (parseInt(btn.dataset.level) === phase.level) {
                    btn.classList.add('active');
                }
            });
            
            // Set next phase text
            if (index + 1 < runningWorkout.phases.length) {
                const nextPhase = runningWorkout.phases[index + 1];
                document.getElementById('runnerNextPhase').textContent = 
                    `${nextPhase.name} (Livello ${nextPhase.level})`;
            } else {
                document.getElementById('runnerNextPhase').textContent = 'Fine allenamento';
            }
            
            // Set resistance
            changePowerLevel(phase.level);
            
            // Single beep to mark phase start (not at workout start)
            if (index > 0) {
                playBeep(1000, 150);
            }
        }

        function updateWorkoutRunner() {
            if (workoutPaused || !runningWorkout) return;
            
            phaseTimeRemaining++;
            totalWorkoutTime++;
            
            const phase = runningWorkout.phases[currentPhaseIndex];
            
            // Calculate progress based on phase type
            let progress = 0;
            let displayValue = '';
            
            if (phase.isKmBased) {
                // KM-based phase: show distance covered
                const distanceCovered = totalDistance - phaseDistanceStart;
                progress = (distanceCovered / phase.duration) * 100;
                displayValue = `${distanceCovered.toFixed(2)} / ${phase.duration.toFixed(1)} km`;
                
                // Check if phase is complete
                if (distanceCovered >= phase.duration) {
                    startPhase(currentPhaseIndex + 1);
                    return;
                }
            } else {
                // Time-based phase: show time elapsed
                progress = (phaseTimeRemaining / phase.duration) * 100;
                const mins = Math.floor(phaseTimeRemaining / 60);
                const secs = phaseTimeRemaining % 60;
                displayValue = `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
                
                // Ski-start countdown beeps at 3 seconds before phase change
                const timeToEnd = phase.duration - phaseTimeRemaining;
                if (timeToEnd === 3) {
                    playSkiStartBeeps();
                }
                
                // Check if phase is complete
                if (phaseTimeRemaining >= phase.duration) {
                    startPhase(currentPhaseIndex + 1);
                    return;
                }
            }
            
            // Update UI
            document.getElementById('runnerTimer').textContent = displayValue;
            document.getElementById('runnerProgressBar').style.width = `${Math.min(progress, 100)}%`;
        }

        function pauseWorkout() {
            workoutPaused = true;
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('resumeBtn').classList.remove('hidden');
            playBeep(600, 200); // Lower beep for pause
        
        if (simulationMode && simulationRunning) { pauseSimulation(); }
    }

        function resumeWorkout() {
            workoutPaused = false;
            document.getElementById('pauseBtn').classList.remove('hidden');
            document.getElementById('resumeBtn').classList.add('hidden');
            playBeep(1000, 200); // Higher beep for resume
        
        if (simulationMode && !simulationRunning) { resumeSimulation(); }
    }

        function stopWorkout() {
            console.log('stopWorkout called');
            
            if (!confirm('Vuoi davvero interrompere l\'allenamento?')) {
                console.log('User cancelled stop');
                return;
            }
            
            stopWorkoutSilent();
        }
        
        function stopWorkoutSilent() {
            console.log('Stopping workout...');
            
            if (workoutTimer) {
                clearInterval(workoutTimer);
                workoutTimer = null;
            }
            
            // Final chart update and show it (if workout was running)
            if (runningWorkout && powerChart) {
                // Re-assign arrays to ensure Chart.js sees them
                powerChart.data.labels = powerChartData.labels;
                powerChart.data.datasets[0].data = powerChartData.values;
                powerChart.update('none');
                document.getElementById('powerChartContainer').classList.remove('hidden');
            }
            
            runningWorkout = null;
            workoutPaused = false;
            
            // Release wake lock
            releaseWakeLock();
            
            // Restore workouts list UI
            document.getElementById('runnerActive').classList.add('hidden');
            document.getElementById('workoutList').style.display = 'grid';
            document.getElementById('newWorkoutBtn').style.display = 'inline-block';
            
            // Reset buttons text and visibility
            document.getElementById('pauseBtn').classList.remove('hidden');
            document.getElementById('resumeBtn').classList.add('hidden');
            document.getElementById('stopBtn').textContent = '‚èπ Stop';
            document.getElementById('stopRunnerBtn').textContent = '‚èπ Stop';
            
            // Reset to level 1
            changePowerLevel(1);
            
            // Stop simulation if running
            if (simulationMode && simulationRunning) { 
                stopSimulation(); 
            }
            
            playBeep(400, 300); // Low beep for stop
            
            // Re-render workout list
            renderWorkoutList();
            
            console.log('Workout stopped successfully');
        }

        function finishWorkout() {
            if (workoutTimer) {
                clearInterval(workoutTimer);
                workoutTimer = null;
            }
            
            // Final chart update and show it
            console.log('=== FINISH WORKOUT DEBUG ===');
            console.log('Power chart exists:', !!powerChart);
            console.log('Data points collected:', powerChartData.values.length);
            console.log('First 10 values:', powerChartData.values.slice(0, 10));
            console.log('Last 10 values:', powerChartData.values.slice(-10));
            console.log('Labels count:', powerChartData.labels.length);
            
            // TEST: Add fake data if no real data was collected
            if (powerChartData.values.length === 0) {
                console.warn('NO DATA COLLECTED! Adding test data...');
                for (let i = 0; i < 20; i++) {
                    powerChartData.labels.push(`${i}s`);
                    powerChartData.values.push(100 + Math.random() * 50);
                }
            }
            
            if (powerChart) {
                // CRITICAL: Re-assign arrays to ensure Chart.js sees them
                powerChart.data.labels = powerChartData.labels;
                powerChart.data.datasets[0].data = powerChartData.values;
                powerChart.update('none');
                
                document.getElementById('powerChartContainer').classList.remove('hidden');
                console.log('Chart container visible');
                console.log('Chart datasets:', powerChart.data.datasets[0].data.length);
            } else {
                console.error('Power chart not initialized!');
            }
            
            // Show completion message
            document.getElementById('runnerCurrentPhase').textContent = '‚úÖ COMPLETATO!';
            document.getElementById('runnerCurrentPhase').style.color = '#00ff88';
            document.getElementById('runnerTimer').textContent = 'üéâ';
            
            // Hide pause/resume buttons, keep only stop
            document.getElementById('pauseBtn').classList.add('hidden');
            document.getElementById('resumeBtn').classList.add('hidden');
            document.getElementById('stopBtn').textContent = '‚úì Chiudi';
            document.getElementById('stopRunnerBtn').textContent = '‚úì Chiudi';
            
            // Victory celebration beeps
            playBeep(800, 150);
            setTimeout(() => playBeep(1000, 150), 200);
            setTimeout(() => playBeep(1200, 300), 400);
        }

        
        // ===== FREE RIDE SESSION CONTROLS =====
        function startFreeRide() {
            if (!connected && !simulationMode) {
                alert('Connetti prima il dispositivo!');
                return;
            }
            
            freeRideActive = true;
            freeRidePaused = false;
            freeRideTime = 0;
            totalDistance = 0;
            lastSpeedUpdate = Date.now(); // Reset for distance calculation
            lastSpeed = 0;
            
            // Reset distance display
            document.getElementById('distanceValue').textContent = '0.0';
            
            // Reset power chart
            resetPowerChart();
            
            // Keep screen on during free ride
            requestWakeLock();
            
            // UI updates - hide start button, show active controls
            document.getElementById('startSessionBtn').classList.add('hidden');
            document.getElementById('sessionActiveControls').classList.remove('hidden');
            document.getElementById('pauseSessionBtn').classList.remove('hidden');
            document.getElementById('resumeSessionBtn').classList.add('hidden');
            
            // Start timer
            freeRideTimer = setInterval(() => {
                if (!freeRidePaused) {
                    freeRideTime++;
        if (simulationMode && !simulationRunning) { startSimulation(); }
                    updateSessionTimer();
                }
            }, 1000);
            
            playBeep(1000, 150);
        }

        function pauseFreeRide() {
            freeRidePaused = true;
            
            // UI updates
            document.getElementById('pauseSessionBtn').classList.add('hidden');
            document.getElementById('resumeSessionBtn').classList.remove('hidden');
            
            playBeep(600, 200);
        
        if (simulationMode && simulationRunning) { pauseSimulation(); }
    }

        function resumeFreeRide() {
            freeRidePaused = false;
            
            // UI updates
            document.getElementById('pauseSessionBtn').classList.remove('hidden');
            document.getElementById('resumeSessionBtn').classList.add('hidden');
            
            playBeep(1000, 200);
        
        if (simulationMode && !simulationRunning) { resumeSimulation(); }
    }

        function stopFreeRide() {
            if (!confirm('Vuoi davvero fermare la sessione di allenamento?')) {
                return;
            }
            
            stopFreeRideSilent();
        }
        
        function stopFreeRideSilent() {
            freeRideActive = false;
            freeRidePaused = false;
            
            if (freeRideTimer) {
                clearInterval(freeRideTimer);
                freeRideTimer = null;
            }
            
            // Final chart update to show all data
            if (powerChart) {
                powerChart.update();
            }
            
            // Stop simulation if running
            if (simulationMode && simulationRunning) { 
                stopSimulation(); 
            }
            
            // UI updates - show start button, hide active controls
            document.getElementById('startSessionBtn').classList.remove('hidden');
            document.getElementById('sessionActiveControls').classList.add('hidden');
            
            freeRideTime = 0;
            updateSessionTimer();
            
            playBeep(400, 300);
        }

        function updateSessionTimer() {
            const mins = Math.floor(freeRideTime / 60);
            const secs = freeRideTime % 60;
            document.getElementById('sessionTimerDisplay').textContent = 
                `${mins.toString().padStart(2, '0')}:${secs.toString().padStart(2, '0')}`;
        }

        
        // ===== EVENT LISTENERS =====
        document.addEventListener('DOMContentLoaded', function() { const simToggle = document.getElementById('simulationToggle'); if (simToggle) simToggle.addEventListener('click', toggleSimulation); });
        scanBtn.addEventListener('click', scanDevices);
        connectBtn.addEventListener('click', connectDevice);
        disconnectBtn.addEventListener('click', disconnectDevice);
        
        document.getElementById('newWorkoutBtn').addEventListener('click', newWorkout);
        document.getElementById('addPhaseBtn').addEventListener('click', () => addPhase());
        document.getElementById('saveWorkoutBtn').addEventListener('click', saveWorkout);
        document.getElementById('cancelEditBtn').addEventListener('click', cancelEdit);
        
        document.getElementById('pauseBtn').addEventListener('click', pauseWorkout);
        document.getElementById('resumeBtn').addEventListener('click', resumeWorkout);
        document.getElementById('stopBtn').addEventListener('click', stopWorkout);
        document.getElementById('stopRunnerBtn').addEventListener('click', stopWorkout);

        // Free ride session controls
        document.getElementById('startSessionBtn').addEventListener('click', startFreeRide);
        document.getElementById('pauseSessionBtn').addEventListener('click', pauseFreeRide);
        document.getElementById('resumeSessionBtn').addEventListener('click', resumeFreeRide);
        document.getElementById('stopSessionBtn').addEventListener('click', stopFreeRide);

        // ===== INITIALIZATION =====
        initLevelButtons();
        loadWorkouts();
        initPowerChart();

        if (!navigator.bluetooth) {
            alert('Web Bluetooth non supportato. Usa Chrome o Edge.');
            scanBtn.disabled = true;
        }
    
    let wakeLock = null;
    let lastConnectedDevice = null;

    async function requestWakeLock() {
        try { 
            if('wakeLock' in navigator) {
                wakeLock = await navigator.wakeLock.request('screen');
                console.log('Wake Lock attivato');
                
                // Re-request wake lock when released (Android bug workaround)
                wakeLock.addEventListener('release', () => {
                    console.log('Wake Lock rilasciato automaticamente');
                    // Auto re-request if session still active
                    if ((freeRideActive || runningWorkout) && (connected || simulationMode)) {
                        setTimeout(() => requestWakeLock(), 100);
                    }
                });
            } else {
                console.warn('Wake Lock API non supportata');
            }
        } catch(e){
            console.error('Wake Lock fallito:', e);
        }
    }

    function releaseWakeLock() {
        if(wakeLock) { 
            wakeLock.release(); 
            wakeLock = null; 
            console.log('Wake Lock rilasciato manualmente');
        }
    }

    document.addEventListener('visibilitychange', async () => {
        if (document.visibilityState === 'visible') {
            // Re-request wake lock when page becomes visible again
            if ((connected || simulationMode) && (freeRideActive || runningWorkout)) {
                await requestWakeLock();
            }
            
            // Try to reconnect device if it was connected
            if (lastConnectedDevice && !connected) {
                try { device = lastConnectedDevice; await connectDevice(); } catch(e){}
            }
        }
    });

    setTimeout(function() {
        var powerBtn = document.getElementById('powerBtn');
        if (powerBtn) {
            powerBtn.onclick = function() { disconnectDevice(); };
        }
    }, 500);

    </script>

    <!-- Version Footer -->
    <div class="version-footer">
        <strong>Zbike Trainer PWA</strong> | Versione <strong id="appVersion">2.5</strong> | ¬© 2026
    </div>
    <script>
    (async function() {
        try {
            const r = await fetch('./sw.js');
            const t = await r.text();
            const m = t.match(/zbike2-v([0-9.]+)/);
            if (m && m[1]) document.getElementById('appVersion').textContent = m[1];
        } catch(e) {}
    })();
    </script>
</body>
</html>
